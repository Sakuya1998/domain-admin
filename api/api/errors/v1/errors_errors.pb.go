// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package v1

import (
	fmt "fmt"
	errors "github.com/go-kratos/kratos/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

func IsUserNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_USER_NOT_FOUND.String() && e.Code == 404
}

func ErrorUserNotFound(format string, args ...interface{}) *errors.Error {
	return errors.New(404, UserErrorReason_USER_NOT_FOUND.String(), fmt.Sprintf(format, args...))
}

func IsUserAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_USER_ALREADY_EXISTS.String() && e.Code == 409
}

func ErrorUserAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, UserErrorReason_USER_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

func IsEmailAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_EMAIL_ALREADY_EXISTS.String() && e.Code == 409
}

func ErrorEmailAlreadyExists(format string, args ...interface{}) *errors.Error {
	return errors.New(409, UserErrorReason_EMAIL_ALREADY_EXISTS.String(), fmt.Sprintf(format, args...))
}

func IsInvalidCredentials(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_INVALID_CREDENTIALS.String() && e.Code == 401
}

func ErrorInvalidCredentials(format string, args ...interface{}) *errors.Error {
	return errors.New(401, UserErrorReason_INVALID_CREDENTIALS.String(), fmt.Sprintf(format, args...))
}

func IsUserInactive(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_USER_INACTIVE.String() && e.Code == 403
}

func ErrorUserInactive(format string, args ...interface{}) *errors.Error {
	return errors.New(403, UserErrorReason_USER_INACTIVE.String(), fmt.Sprintf(format, args...))
}

func IsInvalidPassword(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_INVALID_PASSWORD.String() && e.Code == 400
}

func ErrorInvalidPassword(format string, args ...interface{}) *errors.Error {
	return errors.New(400, UserErrorReason_INVALID_PASSWORD.String(), fmt.Sprintf(format, args...))
}

func IsPasswordTooWeak(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_PASSWORD_TOO_WEAK.String() && e.Code == 400
}

func ErrorPasswordTooWeak(format string, args ...interface{}) *errors.Error {
	return errors.New(400, UserErrorReason_PASSWORD_TOO_WEAK.String(), fmt.Sprintf(format, args...))
}

func IsInvalidEmailFormat(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_INVALID_EMAIL_FORMAT.String() && e.Code == 400
}

func ErrorInvalidEmailFormat(format string, args ...interface{}) *errors.Error {
	return errors.New(400, UserErrorReason_INVALID_EMAIL_FORMAT.String(), fmt.Sprintf(format, args...))
}

func IsUsernameTooShort(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_USERNAME_TOO_SHORT.String() && e.Code == 400
}

func ErrorUsernameTooShort(format string, args ...interface{}) *errors.Error {
	return errors.New(400, UserErrorReason_USERNAME_TOO_SHORT.String(), fmt.Sprintf(format, args...))
}

func IsUsernameTooLong(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_USERNAME_TOO_LONG.String() && e.Code == 400
}

func ErrorUsernameTooLong(format string, args ...interface{}) *errors.Error {
	return errors.New(400, UserErrorReason_USERNAME_TOO_LONG.String(), fmt.Sprintf(format, args...))
}

func IsPermissionDenied(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UserErrorReason_PERMISSION_DENIED.String() && e.Code == 403
}

func ErrorPermissionDenied(format string, args ...interface{}) *errors.Error {
	return errors.New(403, UserErrorReason_PERMISSION_DENIED.String(), fmt.Sprintf(format, args...))
}
